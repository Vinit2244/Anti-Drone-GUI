import React, { PropsWithChildren } from 'react';
import { Map as Map, MapBrowserEvent } from 'ol';
import { Feature } from 'ol';
import BaseVectorLayer from 'ol/layer/BaseVector';
import CanvasVectorLayerRenderer from 'ol/renderer/canvas/VectorLayer';
import SourceVector from 'ol/source/Vector';
import Geometry from 'ol/geom/Geometry';
import BaseEvent from 'ol/events/Event';
import { RContextType } from './context';
import { RlayersBase } from './REvent';
import { RStyleLike } from './style/RStyle';
export declare class RFeatureUIEvent extends MapBrowserEvent<UIEvent> {
    target: Feature<Geometry>;
}
export declare class RFeatureBaseEvent extends BaseEvent {
    target: Feature<Geometry>;
}
/**
 * @propsfor RFeature
 */
export interface RFeatureProps extends PropsWithChildren<unknown> {
    /** OpenLayers geometry, mutually exclusive with feature */
    geometry?: Geometry;
    /** OpenLayers style */
    style?: RStyleLike;
    /** A set of properties that can be accessed later by .get()/.getProperties() */
    properties?: Record<string, unknown>;
    /**
     * Bind the RFeature to an OpenLayers Feature, mutually exclusive with geometry
     *
     * When bound, the RFeature will automatically update its state when the Feature
     * changes
     *
     * geometry is usually a better choice for a dynamic feature
     */
    feature?: Feature<Geometry>;
    /** Called immediately on click */
    onClick?: (this: RFeature, e: RFeatureUIEvent) => boolean | void;
    /** Called on single click when the double click timer has expired */
    onSingleClick?: (this: RFeature, e: RFeatureUIEvent) => boolean | void;
    /** Called on double click */
    onDblClick?: (this: RFeature, e: RFeatureUIEvent) => boolean | void;
    /** Called on every pointer move when dragging, `e.preventDefault()`
     * can be used to stop OpenLayers from also panning the map */
    onPointerDrag?: (this: RFeature, e: RFeatureUIEvent) => boolean | void;
    /** Called when the object is released */
    onPointerDragEnd?: (this: RFeature, e: RFeatureUIEvent) => boolean | void;
    /** Called on every pointer movement over the RFeature, use sparingly */
    onPointerMove?: (this: RFeature, e: RFeatureUIEvent) => boolean | void;
    /** Called once when the pointer moves over the RFeature */
    onPointerEnter?: (this: RFeature, e: RFeatureUIEvent) => boolean | void;
    /** Called once when the pointer moves out of the RFeature */
    onPointerLeave?: (this: RFeature, e: RFeatureUIEvent) => boolean | void;
    /** Called on every change */
    onChange?: (this: RFeature, e: RFeatureBaseEvent) => void;
}
type FeatureRef = {
    feature: Feature<Geometry>;
    layer: BaseVectorLayer<SourceVector<Geometry>, CanvasVectorLayerRenderer>;
};
/**
 * Component for a single vector feature
 *
 * Vector features can be either
 *
 * * implicit, when loaded from a file as props of a `RLayerVector`
 * * explicit, when declared as JSX with this component
 *
 * Requires a vector layer context
 *
 * Provides a location context
 *
 * [Example for explicit RFeatures](https://mmomtchev.github.io/rlayers/#/overlays)
 *
 * [Example for implicit RFeatures](https://mmomtchev.github.io/rlayers/#/RFeatures)
 *
 */
export default class RFeature extends RlayersBase<RFeatureProps, Record<string, never>> {
    static pointerEvents: ('click' | 'pointerdrag' | 'pointermove' | 'singleclick' | 'dblclick')[];
    static lastFeaturesEntered: FeatureRef[];
    static lastFeaturesDragged: FeatureRef[];
    static hitTolerance: number;
    ol: Feature<Geometry>;
    onchange: () => boolean | void;
    constructor(props: Readonly<RFeatureProps>, context?: React.Context<RContextType>);
    static initEventRelay(map: Map): void;
    static dispatchEvent(fr: FeatureRef, event: RFeatureUIEvent): boolean;
    static eventRelay(e: RFeatureUIEvent): boolean;
    refresh(prevProps?: RFeatureProps): void;
    componentDidMount(): void;
    componentWillUnmount(): void;
    render(): JSX.Element;
}
export {};
//# sourceMappingURL=RFeature.d.ts.map