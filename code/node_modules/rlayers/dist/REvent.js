import React from 'react';
import { RContext } from './context';
import debug from './debug';
export class RlayersBase extends React.PureComponent {
    // 'change' is available on all objects
    olEventName(ev) {
        return ev.substring(2).toLowerCase();
    }
    attachEventHandlers() {
        var _a, _b;
        const eventSources = (_a = this.eventSources) !== null && _a !== void 0 ? _a : [this.ol];
        const newEvents = Object.keys(this.props).filter((p) => p.startsWith('on'));
        const eventsToCheck = newEvents.concat(Object.keys((_b = this.handlers) !== null && _b !== void 0 ? _b : {}).filter((ev) => !newEvents.includes(ev)));
        for (const p of eventsToCheck) {
            if (this.handlers === undefined)
                this.handlers = {};
            if (this.handlers[p] !== undefined && this.props[p] === undefined) {
                debug('removing previously installed handler', this, p, this.handlers[p]);
                for (const source of eventSources)
                    source.un(this.olEventName(p), this.handlers[p]);
                this.handlers[p] = undefined;
            }
            if (this.handlers[p] === undefined && this.props[p] !== undefined) {
                debug('installing handler', this, p, this.props[p]);
                this.handlers[p] = (e) => this.props[p].call(this, e);
                for (const source of eventSources)
                    source.on(this.olEventName(p), this.handlers[p]);
            }
        }
    }
    // Used when replacing a source
    attachOldEventHandlers(newSource) {
        // No events have been attached yet
        if (!this.handlers)
            return;
        const events = Object.keys(this.props).filter((p) => p.startsWith('on'));
        for (const e of events) {
            if (this.props[e]) {
                debug('reinstalling existing handler', this, e, this.props[e]);
                newSource.on(this.olEventName(e), this.handlers[e]);
            }
        }
    }
    refresh(prevProps) {
        this.attachEventHandlers();
    }
    componentDidMount() {
        debug('didMount', this);
        this.refresh();
    }
    /* istanbul ignore next */
    propsDiff(prev) {
        if (this.props === null || prev === null) {
            if (this.props !== prev) {
                debug('null props differ', this.props, prev);
                return true;
            }
            return false;
        }
        for (const k of Object.keys(this.props))
            if (this.props[k] !== prev[k]) {
                debug('because of', k, this.props[k], prev[k]);
                return true;
            }
        return false;
    }
    componentDidUpdate(prevProps, prev, snap) {
        if (this.props !== prevProps) {
            debug('willRefresh', this, prevProps, this.props);
            this.refresh(prevProps);
        }
    }
    componentWillUnmount() {
        var _a, _b;
        debug('willUnmount', this, this.handlers);
        const eventSources = (_a = this.eventSources) !== null && _a !== void 0 ? _a : [this.ol];
        for (const h of Object.keys((_b = this.handlers) !== null && _b !== void 0 ? _b : {})) {
            debug('cleaning up handler', this, h, this.handlers[h]);
            if (this.handlers[h]) {
                for (const source of eventSources)
                    source.un(this.olEventName(h), this.handlers[h]);
                this.handlers[h] = undefined;
            }
        }
    }
    render() {
        return null;
    }
}
RlayersBase.contextType = RContext;
//# sourceMappingURL=REvent.js.map