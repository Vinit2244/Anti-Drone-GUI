import React, { PropsWithChildren } from 'react';
import LRU from 'lru-cache';
import { Feature } from 'ol';
import Style, { StyleLike } from 'ol/style/Style';
import Geometry from 'ol/geom/Geometry';
import { RContextType } from '../context';
import { RlayersBase } from '../REvent';
/**
 * @propsfor RStyle
 */
export interface RStyleProps extends PropsWithChildren<unknown> {
    /** render function to be passed the feature and the resolution for dynamic styles
     *
     * a dynamic style cannot become a static style or the inverse
     */
    render?: (feature: Feature<Geometry>, resolution: number) => React.ReactElement;
    /** An optional cache size, valid only for dynamic styles */
    cacheSize?: number;
    /** The cache hashing function, must return a unique string for
     * every unique style computed by the rendering function
     */
    cacheId?: (feature: Feature<Geometry>, resolution: number) => string;
    /** zIndex controls which features are drawn over which features
     * when they overlap
     */
    zIndex?: number;
}
export type RStyleRef = React.RefObject<RStyle>;
export type RStyleLike = RStyleRef | RStyle | StyleLike;
export declare const useRStyle: () => RStyleRef;
export declare const createRStyle: () => RStyleRef;
/**
 * A style, all other style components must be descendants of `RStyle`
 *
 * It can be used with a React reference - `RStyleRef` which is a shortcut for
 * `React.RefObject<RStyle>` and a subtype of `RStyleLike`
 *
 * Or it can also be nested inside a vector layer to be
 * automatically assigned as the default style of that layer
 *
 * This is the only component that does not have to be part of an `RMap`
 *
 * It provides the special `RStyle` context
 */
export default class RStyle extends RlayersBase<RStyleProps, Record<string, never>> {
    ol: StyleLike;
    childRefs: RStyleRef[];
    cache: LRU<string, Style>;
    constructor(props: Readonly<RStyleProps>, context?: React.Context<RContextType>);
    style: (f: Feature<Geometry>, r: number) => Style | Style[];
    componentDidMount(): void;
    refresh(prevProps?: RStyleProps): void;
    render(): JSX.Element;
    /** This is a static function that will return an
     * OpenLayers-compatible `StyleLike` from an `RStyleLike`.
     *
     * @param {RStyleLike} style
     * @public
     */
    static getStyle(style: RStyleLike): StyleLike;
    /** This is a static function that will return an
     * OpenLayers-compatible `Style` from a static `RStyleLike`.
     * This discards the reference and the returned style won't
     * be updated if the referenced `<RStyle>` is updated.
     *
     * It throws if the reference is a dynamic style.
     *
     * @param {RStyleLike} style
     * @public
     */
    static getStyleStatic(style: RStyleLike): Style;
}
//# sourceMappingURL=RStyle.d.ts.map